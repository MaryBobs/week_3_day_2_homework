# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?  
In console.rb when we create the individual properties  

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?  
In properties.sql  

Q3. In `console.rb`, which lines modify the database?  
lines 4, 13, 22, 31 and 33 modify information in the database  

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?  
Because we want it to be created automatically by the database, if we created it there would be the possibility
of errors or duplication.  

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?  
When we save a new instance of a property we save the id. It is done in the save() method in property.rb
At the end of the sql command to insert the four values we have input to create the object we have a return command (line 29),
(I think this returns an array of all the values for our object?)
Then on line 25 the prepared object information is inserted into the database and we also save the first item in
the returned object array (item [0]) as @id . We also make sure it is converted to an integer by using .to_i  


Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?  
Because we only want it to take in a value for id if it already exists.
We don't want nil to be able to be added as the id, or for any information not generated by the database as an id to be able to be inserted.  

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?  
The actions represented by instance methods involve creating a new instance object, or removing objects. Actions represented by the class methods are returning existing information, but not inserting or changing anything in the database.  

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?  
An array is returned so we access the id by getting the value from the first item in the array at position [0]  

Q9. Why do we use prepared statements when performing database operations?  
It helps prevent sql inject attacks. We prepare the data before inserting it, by running db.prepare this checks exactly how many values are expected and that there is not any potentially damaging code added. Only after this step do we insert the prepared data into the database. If there are any issues the program will stop and not insert the information into our database.  

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?  
They each take in one parameter, (id) for find_by_id and (address) for find_by_address. The arguments passed into these parameters are the values we pass in when we call the function in our console.rb file. In the example, "57 Carriers Road, CROESERW, SA13 7GQ" is passed into find_by_address and the id for property2 (property2.id) is passed into find_by_id. The id was assigned to the property2 object when it was saved on line 22, so we are able to then use it.  

Q11. What are their return values?  
They both return a new hash containing all the values for the property that was searched for.  
